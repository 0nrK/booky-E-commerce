{"ast":null,"code":"// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = 'NOT_FOUND';\n\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = undefined;\n    }\n  };\n}\n\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    }); // We found a cached entry\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n\n      return entry.value;\n    } // No entry found in cache, return sentinel\n\n\n    return NOT_FOUND;\n  }\n\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      // TODO Is unshift slow?\n      entries.unshift({\n        key: key,\n        value: value\n      });\n\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n\n  function getEntries() {\n    return entries;\n  }\n\n  function clear() {\n    entries = [];\n  }\n\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\n\nexport var defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\nexport function createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n    var length = prev.length;\n\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n} // defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\n\nexport function defaultMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n      equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,\n      _providedOptions$maxS = providedOptions.maxSize,\n      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n      resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    var value = cache.get(arguments);\n\n    if (value === NOT_FOUND) {\n      // @ts-ignore\n      value = func.apply(null, arguments);\n\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n\n        if (matchingEntry) {\n          value = matchingEntry.value;\n        }\n      }\n\n      cache.put(arguments, value);\n    }\n\n    return value;\n  }\n\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n\n  return memoized;\n}","map":{"version":3,"sources":["/home/nrk/Desktop/projeler/bookStore/client/node_modules/reselect/es/defaultMemoize.js"],"names":["NOT_FOUND","createSingletonCache","equals","entry","get","key","value","put","getEntries","clear","undefined","createLruCache","maxSize","entries","cacheIndex","findIndex","splice","unshift","length","pop","defaultEqualityCheck","a","b","createCacheKeyComparator","equalityCheck","areArgumentsShallowlyEqual","prev","next","i","defaultMemoize","func","equalityCheckOrOptions","providedOptions","_providedOptions$equa","_providedOptions$maxS","resultEqualityCheck","comparator","cache","memoized","arguments","apply","matchingEntry","find","clearCache"],"mappings":"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","sourcesContent":["// Cache implementation based on Erik Rasmussen's `lru-memoize`:\n// https://github.com/erikras/lru-memoize\nvar NOT_FOUND = 'NOT_FOUND';\n\nfunction createSingletonCache(equals) {\n  var entry;\n  return {\n    get: function get(key) {\n      if (entry && equals(entry.key, key)) {\n        return entry.value;\n      }\n\n      return NOT_FOUND;\n    },\n    put: function put(key, value) {\n      entry = {\n        key: key,\n        value: value\n      };\n    },\n    getEntries: function getEntries() {\n      return entry ? [entry] : [];\n    },\n    clear: function clear() {\n      entry = undefined;\n    }\n  };\n}\n\nfunction createLruCache(maxSize, equals) {\n  var entries = [];\n\n  function get(key) {\n    var cacheIndex = entries.findIndex(function (entry) {\n      return equals(key, entry.key);\n    }); // We found a cached entry\n\n    if (cacheIndex > -1) {\n      var entry = entries[cacheIndex]; // Cached entry not at top of cache, move it to the top\n\n      if (cacheIndex > 0) {\n        entries.splice(cacheIndex, 1);\n        entries.unshift(entry);\n      }\n\n      return entry.value;\n    } // No entry found in cache, return sentinel\n\n\n    return NOT_FOUND;\n  }\n\n  function put(key, value) {\n    if (get(key) === NOT_FOUND) {\n      // TODO Is unshift slow?\n      entries.unshift({\n        key: key,\n        value: value\n      });\n\n      if (entries.length > maxSize) {\n        entries.pop();\n      }\n    }\n  }\n\n  function getEntries() {\n    return entries;\n  }\n\n  function clear() {\n    entries = [];\n  }\n\n  return {\n    get: get,\n    put: put,\n    getEntries: getEntries,\n    clear: clear\n  };\n}\n\nexport var defaultEqualityCheck = function defaultEqualityCheck(a, b) {\n  return a === b;\n};\nexport function createCacheKeyComparator(equalityCheck) {\n  return function areArgumentsShallowlyEqual(prev, next) {\n    if (prev === null || next === null || prev.length !== next.length) {\n      return false;\n    } // Do this in a for loop (and not a `forEach` or an `every`) so we can determine equality as fast as possible.\n\n\n    var length = prev.length;\n\n    for (var i = 0; i < length; i++) {\n      if (!equalityCheck(prev[i], next[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n}\n// defaultMemoize now supports a configurable cache size with LRU behavior,\n// and optional comparison of the result value with existing values\nexport function defaultMemoize(func, equalityCheckOrOptions) {\n  var providedOptions = typeof equalityCheckOrOptions === 'object' ? equalityCheckOrOptions : {\n    equalityCheck: equalityCheckOrOptions\n  };\n  var _providedOptions$equa = providedOptions.equalityCheck,\n      equalityCheck = _providedOptions$equa === void 0 ? defaultEqualityCheck : _providedOptions$equa,\n      _providedOptions$maxS = providedOptions.maxSize,\n      maxSize = _providedOptions$maxS === void 0 ? 1 : _providedOptions$maxS,\n      resultEqualityCheck = providedOptions.resultEqualityCheck;\n  var comparator = createCacheKeyComparator(equalityCheck);\n  var cache = maxSize === 1 ? createSingletonCache(comparator) : createLruCache(maxSize, comparator); // we reference arguments instead of spreading them for performance reasons\n\n  function memoized() {\n    var value = cache.get(arguments);\n\n    if (value === NOT_FOUND) {\n      // @ts-ignore\n      value = func.apply(null, arguments);\n\n      if (resultEqualityCheck) {\n        var entries = cache.getEntries();\n        var matchingEntry = entries.find(function (entry) {\n          return resultEqualityCheck(entry.value, value);\n        });\n\n        if (matchingEntry) {\n          value = matchingEntry.value;\n        }\n      }\n\n      cache.put(arguments, value);\n    }\n\n    return value;\n  }\n\n  memoized.clearCache = function () {\n    return cache.clear();\n  };\n\n  return memoized;\n}"]},"metadata":{},"sourceType":"module"}